<html>
    <!-- Ваш замечательный код -->
     <head>
       <meta charset="utf-8">
       <title>Task 1</title>
    </head>
    <body>
        <p>Блог компании Яндекс.</p>
        <p>ЯНДЕКС.ПОЧТА: КАК МЫ ИЗМЕРЯЕМ СКОРОСТЬ ЗАГРУЗКИ И УЛУЧШАЕМ ЕЁ</p>

        Если ваш сайт медленно грузится, вы рискуете тем, что люди не оценят ни то,<br>
        какой он красивый, ни то, какой он удобный. Никому не понравится, когда все<br>
        тормозит. Мы регулярно добавляем в Яндекс.Почту новую функциональность,<br>
        иногда — исправляем ошибки, а это значит, у нас постоянно появляются новый код<br>
        и новая логика. Всё это напрямую влияет на скорость работы интерфейса.
        
        <p>Что мы измеряем</p>
        
        Этапы первой загрузки:<br>
				* подготовка;<br>
				* загрузка статики (HTTP-запрос и парсинг);<br>
				* исполнение модулей;<br>
				* инициализация базовых объектов;<br>
				* отрисовка.<br><br>
        
        Этапы отрисовки любой страницы:<br>
				* подготовка к запросу на сервер;<br>
				* запрос данных с сервера;<br>
				* шаблонизация;<br>
				* обновление DOM.<br><br>
        
        — «Ок, теперь у нас есть метрики, мы можем отправить их на сервер» - говорим мы<br>
				— «Что же дальше?» - вопрошаете вы<br>
				— «А давай построим график!» - отвечаем мы<br>
				— «А что будем считать?» - уточняете вы<br><br>
        
        Как вы знаете, медиана – это серединное, а не среднее значение в выборке.<br>
				Если у нас имеются числа 1, 2, 2, 3, 8, 10, 20, то медиана – 3, а среднее – 6,5.<br>
				В общем случае медиана отлично показывает, сколько грузится средний пользователь.<br><br>
        
        В случае ускорения или замедления медиана, конечно, изменится. Но она не может<br>
				рассказать, сколько пользователей ускорилось, а сколько замедлилось.<br><br>
        
        APDEX – метрика, которая сразу говорит: хорошо или плохо. Метрика<br>
				работает очень просто. Мы выбираем временной интервал [0; t], такой, что если<br>
				время показа страницы попало в него, то пользователь счастлив. Берем еще один<br>
				интервал, (t; 4t] (в четыре раза больше первого), и считаем, что если страница<br>
				показана за это время, то пользователь в целом удовлетворен скоростью работы,<br>
				но уже не настолько счастлив. И применяем формулу:<br><br>
        
        (кол-во счастливых пользователей + кол-во удовлетворенных / 2) / (кол-во всех).<br>
				Получается значение от нуля до единицы, которое, видимо, лучше всего показывает,<br>
				хорошо или плохо работает почта.<br><br>
        
        Как мы измеряем<br><br>

        Сейчас модуль обновления сам логирует все свои стадии, и можно легко понять<br>
				причину замедления: медленнее стал отвечать сервер либо слишком долго<br>
				выполняется JavaScript. Выглядит это примерно так:<br><br>
        
        <code>this.timings['look-ma-im-start'] = Date.now();</code><br>
				<code>this.timings['look-ma-finish'] = Date.now();</code><br><br>
        
        C помощью Date.now() мы получаем текущее время. Все тайминги собираются и при<br>
				отправке рассчитываются. На этапах разница между “end” и “start” не считается,<br>
				а все вычисления производятся в конце:<br><br>
        
        <code>var totalTime = this.timings['look-ma-finish'] - this.timings['look-ma-im-start'];</code><br><br>
        
        И на сервер прилетают подобные записи:<br><br>
        
        <code>serverResponse=50&domUpdate=60</code><br><br>

				Как мы ускоряем<br><br>

				Чтобы снизить время загрузки почты при выходе новых версий,<br>
				мы уже делаем следующее:<br><br>

				* включаем gzip;<br>
				* выставляем заголовки кэширования;<br>
				* фризим CSS, JS, шаблоны и картинки;<br>
				* используем CDN;<br><br>
        
        Мы подумали: «А что если хранить где-то старую версию файлов, а при выходе новой<br>
				передавать только diff между ней и той, которая сохранена у пользователя?»<br>
				В браузере же останется просто наложить патч на клиенте.<br><br>

				На самое деле эта идея не нова. Уже существуют стандарты для HTTP — например,<br>
				RFC 3229 «Delta encoding in HTTP» и «Google SDHC», — но по разным причинам они<br>
				не получили должного распространения в браузерах и на серверах.<br><br>

				Мы же решили сделать свой аналог на JS. Чтобы реализовать этот метод обновления,<br>
				начали искать реализации diff на JS. На популярных хостингах кода нашли<br>
				библиотеки:<br>
				- VCDiff<br>
				- google-diff-patch-match<br><br>
	
				Для окончательного выбора библиотеки нам нужно сравнить:<br><br>
        
        Библиотека      | IE 9          | Opera 12<br>
				----------      | ----          | --------<br>
				vcdiff          | 8             | 5<br>
				google diff     | 1363          | 76<br><br>

				После того как мы определились с библиотекой для диффа, нужно определиться с тем,<br>
				где и как хранить статику на клиенте.<br><br>

				Формат файла с патчами для проекта выглядит так:<br>
        <code>
					[<br>
    					{<br>
       					<blockquote> "k": "jane.css",<br></blockquote>
        					"p": [patch],<br>
       						 "s": 4554<br>
   					 },<br>
   					 {<br>
     					   "k": "jane.css",<br>
      						  "p": [patch],<br>
     					   "s": 4554<br>
  						  }<br>
					]</code><br><br>

То есть это обычный массив из объектов. Каждый объект — отдельный ресурс. У
каждого объекта есть три свойства. k — названия ключа в localStorage для этого
ресурса. p — патч для ресурса, который сгенерировал vcdiff. s — чексумма для
ресурса актуальной версии, чтобы потом можно было проверить правильность
наложения патча на клиенте. Чексумма вычисляется по алгоритму Флетчера.

Алгоритм Бройдена — Флетчера — Гольдфарба — Шанно (BFGS)
— итерационный метод численной оптимизации, предназначенный для
нахождения локального максимума/минимума нелинейного функционала
без ограничений.

Почему именно алгоритм Флетчера, а не другие популярные алгоритмы вроде:
CRC16/32 - алгоритм нахождения контрольной суммы, предназначенный для проверки
целостности данных
md5 - 128-битный алгоритм хеширования. Предназначен для создания «отпечатков»
или дайджестов сообщения произвольной длины и последующей проверки
их подлинности.

Потому что он быстрый, компактный и легок в реализации.

Итог

Фактически мы экономим 80-90% трафика. Размер загружаемой статитки в байтах:

Релиз  | С патчем     | Без патча
7.7.20  | 397          | 174 549
7.7.21  | 383          | 53 995
7.7.22  | 483          | 3 995

Автор: @doochik
С++ разработик
Электронная почта: (doochik@yandex-team.ru)
Компания: Яндекс

Комментарии (3):

- Mogaika (mogaika@yandex-team.ru) 30 ноября 2014 в 17:05

  А можете привести сравнение, на сколько быстрее грузится lite версия?

- JIguse (mrawesome@yandex.ru) 29 ноября 2014 в 21:30

  Спасибо за статью, познавательно. Здорово, что Яндекс делится некоторыми
  подробностями о внутренней работе сервисов.

- Brister (brist89@yandex-team.ru) 24 ноября 2014 в 13:13

  (кол-во счастливых пользователей + кол-во удовлетворенных / 2) / (кол-во всех).
  Получается значение от нуля до единицы, которое, видимо, лучше всего показывает,
  хорошо или плохо работает почта.

  наверное все-таки от 0.5 до 1

- alexeimois (test@yandex.ru) 22 ноября 2014 в 17:35

  Мы измеряем скорость загрузки с помощью Яндекс.Метрики:
  help.yandex.ru/metrika/reports/monitoring_timing.xml

© Яндекс, help@yandex.ru, Хохрякова, 10
        
        
        
    </body>
</html>
